# Provably Fair – Fun Casino (Mines & Plinko)

This document explains how the provably fair system works for the Fun casino MVP and how to verify game outcomes via API and the `/fairness` page.

## 1. Core concepts

- **Server seed**: a secret random hex string generated by the backend for each bet (MVP). In a future version, it can be session-based with a published hash.
- **Client seed**: a string chosen by the user (or generated client-side) and sent with the bet.
- **Nonce**: an integer counter that increments per bet for a given user.
- **HMAC-SHA256**: we compute a deterministic hash:

  \[
    \text{hash} = \text{HMAC-SHA256}(\text{serverSeed}, \text{clientSeed}:\text{nonce}:\text{cursor})
  \]

  where `cursor` is an integer used to derive multiple random values from the same triplet.

- **Random float**: from the HMAC output we derive a pseudo-random float in \([0,1)\) using the first 52 bits.

All of this is implemented in `backend/src/common/utils/provably-fair.util.ts` and is reused by the game engines and the fairness verification endpoints.

## 2. Mines – engine and verification

### 2.1 Engine

`backend/src/games/mines.engine.ts` exposes:

- `resolveMinesBet(amount, serverSeed, clientSeed, nonce, params)` where `params = { rows, cols, minesCount }`.
- Steps:
  - Total cells = `rows * cols`.
  - Mine positions:
    - We repeatedly call `getRandomFloat01(serverSeed, clientSeed, nonce, cursor++)` to sample positions in `[0, totalCells)`, ensuring uniqueness.
  - Safe tiles:
    - `maxSafe = totalCells - minesCount`.
    - Another random float with a fixed cursor (e.g. `cursor = 999`) determines `safeRevealed` in `[0, maxSafe]`.
    - If `safeRevealed === 0`, the player “hits a mine” (multiplier `0`).
  - Multiplier:
    - A deterministic function of `minesCount`, `safeRevealed` and `maxSafe` computes `finalMultiplier`.

The function returns:

```jsonc
{
  "rows": 5,
  "cols": 5,
  "minesCount": 5,
  "minePositions": [1, 7, 12, 18, 23],
  "safeRevealed": 4,
  "finalMultiplier": 2.5,
  "hitMine": false
}
```

### 2.2 Verification APIs

#### POST `/fairness/mines/verify-manual`

Body:

```json
{
  "serverSeed": "...",
  "clientSeed": "my-seed",
  "nonce": 42,
  "amount": 100,
  "rows": 5,
  "cols": 5,
  "minesCount": 5
}
```

Response:

```json
{
  "gameData": { "...": "same format as Bet.gameData" },
  "multiplier": 2.5,
  "expectedPayout": "250.00000000"
}
```

You can re-run this locally with the same inputs and confirm the result.

#### GET `/fairness/mines/verify-bet/:betId`

- Authenticated (requires `X-User-Id`).
- Loads the stored bet (only if it belongs to the current user).
- Recomputes the result using the stored:
  - `serverSeed`, `clientSeed`, `nonce`,
  - `amount`,
  - game parameters from `gameData` (`rows`, `cols`, `minesCount`).

Response:

```json
{
  "betId": "bet_123",
  "valid": true,
  "stored": {
    "multiplier": 2.5,
    "payout": "250.00000000",
    "gameData": { "...": "as stored in DB" }
  },
  "recomputed": {
    "multiplier": 2.5,
    "payout": "250.00000000",
    "gameData": { "...": "recomputed from seeds" }
  }
}
```

If anything differs (multiplier, payout, or gameData), `valid` will be `false` and the differences are visible by comparing the `stored` vs `recomputed` blocks.

## 3. Plinko – engine and verification

### 3.1 Engine

`backend/src/games/plinko.engine.ts` exposes:

- `resolvePlinkoBet(amount, serverSeed, clientSeed, nonce, params)` where `params = { rows, risk }`.
- Steps:
  - For each of `rows` steps, we generate `L`/`R` using `getRandomFloat01(serverSeed, clientSeed, nonce, cursor=i)`.
  - The number of `R` moves determines a slot index.
  - That index is mapped to a multiplier table depending on `risk = low|medium|high`.

Output:

```jsonc
{
  "rows": 12,
  "risk": "medium",
  "path": ["L","R","L", "..."],
  "finalSlot": 6,
  "finalMultiplier": 2.0
}
```

### 3.2 Verification APIs

#### POST `/fairness/plinko/verify-manual`

Body:

```json
{
  "serverSeed": "...",
  "clientSeed": "my-seed",
  "nonce": 42,
  "amount": 100,
  "rows": 12,
  "risk": "medium"
}
```

Response:

```json
{
  "gameData": { "...": "same format as Bet.gameData" },
  "multiplier": 2.0,
  "expectedPayout": "200.00000000"
}
```

#### GET `/fairness/plinko/verify-bet/:betId`

Same idea as Mines:

```json
{
  "betId": "bet_456",
  "valid": true,
  "stored": {
    "multiplier": 2.0,
    "payout": "200.00000000",
    "gameData": { "...": "stored" }
  },
  "recomputed": {
    "multiplier": 2.0,
    "payout": "200.00000000",
    "gameData": { "...": "recomputed" }
  }
}
```

## 4. Frontend – `/fairness` page

The Next.js page `frontend/app/fairness/page.tsx` provides:

- **Verify by Bet ID**:
  - Inputs: betId + gameType (Mines/Plinko).
  - Calls the appropriate `/fairness/*/verify-bet/:betId` endpoint.
  - Shows whether `valid` is `YES`/`NO` and renders both stored and recomputed data.
- **Manual verification**:
  - **Mines** section:
    - Inputs: serverSeed, clientSeed, nonce, amount, rows, cols, minesCount.
    - Calls `POST /fairness/mines/verify-manual`.
    - Shows multiplier, expected payout and the full `gameData`.
  - **Plinko** section:
    - Inputs: serverSeed, clientSeed, nonce, amount, rows, risk.
    - Calls `POST /fairness/plinko/verify-manual`.
    - Shows multiplier, expected payout and the full `gameData`.

All requests use the same provably fair engine code as the live bets, ensuring that verification and gameplay are perfectly aligned.


